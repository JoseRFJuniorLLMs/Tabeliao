/**
 * @tabeliao/contracts-sdk
 *
 * Provides TypeScript types, ABI loading utilities, and contract factory
 * types for interacting with Tabeliao's Solidity smart contracts via Ethers.js.
 *
 * After smart contracts are compiled, the generated ABIs and typechain output
 * will populate the concrete implementations referenced here.
 */

// ---------------------------------------------------------------------------
// Contract Addresses
// ---------------------------------------------------------------------------

/** Known contract names deployed on the Tabeliao platform */
export type ContractName =
  | 'EscrowManager'
  | 'ContractRegistry'
  | 'DisputeResolver'
  | 'PaymentSplitter';

/** Map of contract names to their deployed addresses per network */
export interface ContractAddresses {
  [network: string]: {
    [K in ContractName]?: string;
  };
}

/** Default contract addresses (populated after deployment) */
export const CONTRACT_ADDRESSES: ContractAddresses = {
  localhost: {
    EscrowManager: '0x0000000000000000000000000000000000000000',
    ContractRegistry: '0x0000000000000000000000000000000000000000',
    DisputeResolver: '0x0000000000000000000000000000000000000000',
    PaymentSplitter: '0x0000000000000000000000000000000000000000',
  },
  sepolia: {},
  mainnet: {},
};

// ---------------------------------------------------------------------------
// ABI Types and Loader
// ---------------------------------------------------------------------------

/** Minimal representation of a Solidity ABI entry */
export interface AbiEntry {
  type: 'function' | 'event' | 'constructor' | 'fallback' | 'receive' | 'error';
  name?: string;
  inputs?: AbiParameter[];
  outputs?: AbiParameter[];
  stateMutability?: 'pure' | 'view' | 'nonpayable' | 'payable';
  anonymous?: boolean;
}

/** Parameter in an ABI entry */
export interface AbiParameter {
  name: string;
  type: string;
  indexed?: boolean;
  components?: AbiParameter[];
  internalType?: string;
}

/** Storage for loaded ABIs keyed by contract name */
const abiCache: Map<ContractName, AbiEntry[]> = new Map();

/**
 * Registers an ABI for a given contract name.
 * Call this after loading compiled artifacts (e.g., from Hardhat).
 */
export function registerAbi(name: ContractName, abi: AbiEntry[]): void {
  abiCache.set(name, abi);
}

/**
 * Retrieves the ABI for a given contract name.
 * Throws if the ABI has not been registered yet.
 */
export function getAbi(name: ContractName): AbiEntry[] {
  const abi = abiCache.get(name);
  if (!abi) {
    throw new Error(
      `ABI for "${name}" not found. Call registerAbi() after compiling contracts.`,
    );
  }
  return abi;
}

/**
 * Returns the deployed address for a contract on the specified network.
 * Throws if no address is registered for that contract/network combination.
 */
export function getContractAddress(
  name: ContractName,
  network: string,
): string {
  const networkAddresses = CONTRACT_ADDRESSES[network];
  if (!networkAddresses) {
    throw new Error(`No addresses registered for network "${network}".`);
  }
  const address = networkAddresses[name];
  if (!address || address === '0x0000000000000000000000000000000000000000') {
    throw new Error(
      `Contract "${name}" not deployed on network "${network}".`,
    );
  }
  return address;
}

// ---------------------------------------------------------------------------
// Contract Factory Types
// ---------------------------------------------------------------------------

/**
 * Generic contract factory interface.
 * Concrete implementations will be generated by TypeChain after Solidity
 * compilation. Each factory connects to a deployed contract via Ethers.js.
 */
export interface IContractFactory<T> {
  connect(address: string, signerOrProvider: unknown): T;
  deploy(...args: unknown[]): Promise<T>;
}

/** Escrow manager contract interface */
export interface IEscrowManagerContract {
  deposit(contractId: string, amount: bigint): Promise<unknown>;
  release(contractId: string, to: string): Promise<unknown>;
  refund(contractId: string): Promise<unknown>;
  getBalance(contractId: string): Promise<bigint>;
  getEscrowDetails(contractId: string): Promise<{
    depositor: string;
    amount: bigint;
    released: boolean;
    createdAt: bigint;
  }>;
}

/** Contract registry contract interface */
export interface IContractRegistryContract {
  registerContract(contractId: string, hash: string): Promise<unknown>;
  verifyContract(contractId: string, hash: string): Promise<boolean>;
  getContractHash(contractId: string): Promise<string>;
  getRegistrationTimestamp(contractId: string): Promise<bigint>;
}

/** Dispute resolver contract interface */
export interface IDisputeResolverContract {
  openDispute(contractId: string, description: string): Promise<unknown>;
  submitEvidence(disputeId: string, evidenceHash: string): Promise<unknown>;
  resolveDispute(disputeId: string, resolution: string, inFavorOf: string): Promise<unknown>;
  getDisputeDetails(disputeId: string): Promise<{
    contractId: string;
    opener: string;
    status: number;
    resolution: string;
    resolvedAt: bigint;
  }>;
}

/** Payment splitter contract interface */
export interface IPaymentSplitterContract {
  addPayee(payee: string, shares: bigint): Promise<unknown>;
  release(payee: string): Promise<unknown>;
  totalShares(): Promise<bigint>;
  totalReleased(): Promise<bigint>;
  shares(payee: string): Promise<bigint>;
  released(payee: string): Promise<bigint>;
}

/** Factory type map for type-safe factory retrieval */
export interface ContractFactoryMap {
  EscrowManager: IContractFactory<IEscrowManagerContract>;
  ContractRegistry: IContractFactory<IContractRegistryContract>;
  DisputeResolver: IContractFactory<IDisputeResolverContract>;
  PaymentSplitter: IContractFactory<IPaymentSplitterContract>;
}

/**
 * Retrieves a typed contract factory by name.
 * The actual factory implementations will be available after TypeChain
 * generation from compiled Solidity artifacts.
 *
 * Usage after contracts are compiled:
 * ```ts
 * import { getContractFactory } from '@tabeliao/contracts-sdk';
 * const factory = getContractFactory('EscrowManager');
 * const contract = factory.connect(address, signer);
 * ```
 */
export function getContractFactory<K extends ContractName>(
  _name: K,
): ContractFactoryMap[K] {
  throw new Error(
    `Contract factory for "${_name}" not available. ` +
    'Compile Solidity contracts and run TypeChain to generate factories.',
  );
}
